import { Reaction, _getGlobalState } from "mobx";
import React from "react";
import { printDebugValue } from "./utils/printDebugValue";
import { isUsingStaticRendering } from "./staticRendering";
import { observerFinalizationRegistry } from "./utils/observerFinalizationRegistry";
import { useSyncExternalStore } from "use-sync-external-store/shim";
var mobxGlobalState = _getGlobalState();
// BC
var globalStateVersionIsAvailable = typeof mobxGlobalState.globalVersion !== "undefined";
function createReaction(adm) {
    adm.reaction = new Reaction("observer".concat(adm.name), function () {
        var _a;
        if (!globalStateVersionIsAvailable) {
            // BC
            adm.stateVersion = Symbol();
        }
        // Force update won't be avaliable until the component "mounts".
        // If state changes in between initial render and mount,
        // `useSyncExternalStore` should handle that by checking the state version and issuing update.
        (_a = adm.forceUpdate) === null || _a === void 0 ? void 0 : _a.call(adm);
    });
}
export function useObserver(render, baseComponentName) {
    if (baseComponentName === void 0) { baseComponentName = "observed"; }
    if (isUsingStaticRendering()) {
        return render();
    }
    var admRef = React.useRef(null);
    if (!admRef.current) {
        // First render
        var adm_1 = {
            reaction: null,
            forceUpdate: null,
            stateVersion: Symbol(),
            name: baseComponentName,
            subscribe: function (onStoreChange) {
                // Do NOT access admRef here!
                observerFinalizationRegistry.unregister(adm_1);
                adm_1.forceUpdate = onStoreChange;
                if (!adm_1.reaction) {
                    // We've lost our reaction and therefore all subscriptions.
                    // We have to recreate reaction and schedule re-render to recreate subscriptions,
                    // even if state did not change.
                    createReaction(adm_1);
                    adm_1.forceUpdate();
                }
                return function () {
                    var _a;
                    // Do NOT access admRef here!
                    adm_1.forceUpdate = null;
                    (_a = adm_1.reaction) === null || _a === void 0 ? void 0 : _a.dispose();
                    adm_1.reaction = null;
                };
            },
            getSnapshot: function () {
                // Do NOT access admRef here!
                return globalStateVersionIsAvailable
                    ? mobxGlobalState.stateVersion
                    : adm_1.stateVersion;
            }
        };
        admRef.current = adm_1;
    }
    var adm = admRef.current;
    if (!adm.reaction) {
        // First render or reaction was disposed by registry before subscribe
        createReaction(adm);
        // StrictMode/ConcurrentMode/Suspense may mean that our component is
        // rendered and abandoned multiple times, so we need to track leaked
        // Reactions.
        observerFinalizationRegistry.register(admRef, adm, adm);
    }
    React.useDebugValue(adm.reaction, printDebugValue);
    useSyncExternalStore(
    // Both of these must be stable, otherwise it would keep resubscribing every render.
    adm.subscribe, adm.getSnapshot);
    // render the original component, but have the
    // reaction track the observables, so that rendering
    // can be invalidated (see above) once a dependency changes
    var renderResult;
    var exception;
    adm.reaction.track(function () {
        try {
            renderResult = render();
        }
        catch (e) {
            exception = e;
        }
    });
    if (exception) {
        throw exception; // re-throw any exceptions caught during rendering
    }
    return renderResult;
}
//# sourceMappingURL=useObserver.js.map